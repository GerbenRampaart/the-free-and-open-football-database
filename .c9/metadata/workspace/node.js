{"changed":false,"filter":false,"title":"node.js","tooltip":"/node.js","value":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by node::Load in src/node.cc, and responsible for\n// bootstrapping the node.js core. Special caution is given to the performance\n// of the startup process, so many dependencies are invoked lazily.\n(function(process) {\n  this.global = this;\n\n  function startup() {\n    var EventEmitter = NativeModule.require('events').EventEmitter;\n\n    process.__proto__ = Object.create(EventEmitter.prototype, {\n      constructor: {\n        value: process.constructor\n      }\n    });\n    EventEmitter.call(process);\n\n    process.EventEmitter = EventEmitter; // process.EventEmitter is deprecated\n\n    // do this good and early, since it handles errors.\n    startup.processFatal();\n\n    startup.globalVariables();\n    startup.globalTimeouts();\n    startup.globalConsole();\n\n    startup.processAssert();\n    startup.processConfig();\n    startup.processNextTick();\n    startup.processStdio();\n    startup.processKillAndExit();\n    startup.processSignalHandlers();\n\n    startup.processChannel();\n\n    startup.resolveArgv0();\n\n    // There are various modes that Node can run in. The most common two\n    // are running from a script and running the REPL - but there are a few\n    // others like the debugger or running --eval arguments. Here we decide\n    // which mode we run in.\n\n    if (NativeModule.exists('_third_party_main')) {\n      // To allow people to extend Node in different ways, this hook allows\n      // one to drop a file lib/_third_party_main.js into the build\n      // directory which will be executed instead of Node's normal loading.\n      process.nextTick(function() {\n        NativeModule.require('_third_party_main');\n      });\n\n    } else if (process.argv[1] == 'debug') {\n      // Start the debugger agent\n      var d = NativeModule.require('_debugger');\n      d.start();\n\n    } else if (process._eval != null) {\n      // User passed '-e' or '--eval' arguments to Node.\n      evalScript('[eval]');\n    } else if (process.argv[1]) {\n      // make process.argv[1] into a full path\n      var path = NativeModule.require('path');\n      process.argv[1] = path.resolve(process.argv[1]);\n\n      // If this is a worker in cluster mode, start up the communiction\n      // channel.\n      if (process.env.NODE_UNIQUE_ID) {\n        var cluster = NativeModule.require('cluster');\n        cluster._setupWorker();\n\n        // Make sure it's not accidentally inherited by child processes.\n        delete process.env.NODE_UNIQUE_ID;\n      }\n\n      var Module = NativeModule.require('module');\n\n      if (global.v8debug &&\n          process.execArgv.some(function(arg) {\n            return arg.match(/^--debug-brk(=[0-9]*)?$/);\n          })) {\n\n        // XXX Fix this terrible hack!\n        //\n        // Give the client program a few ticks to connect.\n        // Otherwise, there's a race condition where `node debug foo.js`\n        // will not be able to connect in time to catch the first\n        // breakpoint message on line 1.\n        //\n        // A better fix would be to somehow get a message from the\n        // global.v8debug object about a connection, and runMain when\n        // that occurs.  --isaacs\n\n        var debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || 50;\n        setTimeout(Module.runMain, debugTimeout);\n\n      } else {\n        // Main entry point into most programs:\n        Module.runMain();\n      }\n\n    } else {\n      var Module = NativeModule.require('module');\n\n      // If -i or --interactive were passed, or stdin is a TTY.\n      if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n        // REPL\n        var opts = {\n          useGlobal: true,\n          ignoreUndefined: false\n        };\n        if (parseInt(process.env['NODE_NO_READLINE'], 10)) {\n          opts.terminal = false;\n        }\n        if (parseInt(process.env['NODE_DISABLE_COLORS'], 10)) {\n          opts.useColors = false;\n        }\n        var repl = Module.requireRepl().start(opts);\n        repl.on('exit', function() {\n          process.exit();\n        });\n\n      } else {\n        // Read all of stdin - execute it.\n        process.stdin.setEncoding('utf8');\n\n        var code = '';\n        process.stdin.on('data', function(d) {\n          code += d;\n        });\n\n        process.stdin.on('end', function() {\n          process._eval = code;\n          evalScript('[stdin]');\n        });\n      }\n    }\n  }\n\n  startup.globalVariables = function() {\n    global.process = process;\n    global.global = global;\n    global.GLOBAL = global;\n    global.root = global;\n    global.Buffer = NativeModule.require('buffer').Buffer;\n    process.binding('buffer').setFastBufferConstructor(global.Buffer);\n    process.domain = null;\n    process._exiting = false;\n  };\n\n  startup.globalTimeouts = function() {\n    global.setTimeout = function() {\n      var t = NativeModule.require('timers');\n      return t.setTimeout.apply(this, arguments);\n    };\n\n    global.setInterval = function() {\n      var t = NativeModule.require('timers');\n      return t.setInterval.apply(this, arguments);\n    };\n\n    global.clearTimeout = function() {\n      var t = NativeModule.require('timers');\n      return t.clearTimeout.apply(this, arguments);\n    };\n\n    global.clearInterval = function() {\n      var t = NativeModule.require('timers');\n      return t.clearInterval.apply(this, arguments);\n    };\n\n    global.setImmediate = function() {\n      var t = NativeModule.require('timers');\n      return t.setImmediate.apply(this, arguments);\n    };\n\n    global.clearImmediate = function() {\n      var t = NativeModule.require('timers');\n      return t.clearImmediate.apply(this, arguments);\n    };\n  };\n\n  startup.globalConsole = function() {\n    global.__defineGetter__('console', function() {\n      return NativeModule.require('console');\n    });\n  };\n\n\n  startup._lazyConstants = null;\n\n  startup.lazyConstants = function() {\n    if (!startup._lazyConstants) {\n      startup._lazyConstants = process.binding('constants');\n    }\n    return startup._lazyConstants;\n  };\n\n  startup.processFatal = function() {\n    // call into the active domain, or emit uncaughtException,\n    // and exit if there are no listeners.\n    process._fatalException = function(er) {\n      var caught = false;\n      if (process.domain) {\n        var domain = process.domain;\n        var domainModule = NativeModule.require('domain');\n        var domainStack = domainModule._stack;\n\n        // ignore errors on disposed domains.\n        //\n        // XXX This is a bit stupid.  We should probably get rid of\n        // domain.dispose() altogether.  It's almost always a terrible\n        // idea.  --isaacs\n        if (domain._disposed)\n          return true;\n\n        er.domain = domain;\n        er.domainThrown = true;\n        // wrap this in a try/catch so we don't get infinite throwing\n        try {\n          // One of three things will happen here.\n          //\n          // 1. There is a handler, caught = true\n          // 2. There is no handler, caught = false\n          // 3. It throws, caught = false\n          //\n          // If caught is false after this, then there's no need to exit()\n          // the domain, because we're going to crash the process anyway.\n          caught = domain.emit('error', er);\n\n          // Exit all domains on the stack.  Uncaught exceptions end the\n          // current tick and no domains should be left on the stack\n          // between ticks.\n          var domainModule = NativeModule.require('domain');\n          domainStack.length = 0;\n          domainModule.active = process.domain = null;\n        } catch (er2) {\n          // The domain error handler threw!  oh no!\n          // See if another domain can catch THIS error,\n          // or else crash on the original one.\n          // If the user already exited it, then don't double-exit.\n          if (domain === domainModule.active)\n            domainStack.pop();\n          if (domainStack.length) {\n            var parentDomain = domainStack[domainStack.length - 1];\n            process.domain = domainModule.active = parentDomain;\n            caught = process._fatalException(er2);\n          } else\n            caught = false;\n        }\n      } else {\n        caught = process.emit('uncaughtException', er);\n      }\n      // if someone handled it, then great.  otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event\n      if (!caught) {\n        try {\n          if (!process._exiting) {\n            process._exiting = true;\n            process.emit('exit', 1);\n          }\n        } catch (er) {\n          // nothing to be done about it at this point.\n        }\n      }\n      // if we handled an error, then make sure any ticks get processed\n      if (caught)\n        process._needTickCallback();\n      return caught;\n    };\n  };\n\n  var assert;\n  startup.processAssert = function() {\n    // Note that calls to assert() are pre-processed out by JS2C for the\n    // normal build of node. They persist only in the node_g build.\n    // Similarly for debug().\n    assert = process.assert = function(x, msg) {\n      if (!x) throw new Error(msg || 'assertion error');\n    };\n  };\n\n  startup.processConfig = function() {\n    // used for `process.config`, but not a real module\n    var config = NativeModule._source.config;\n    delete NativeModule._source.config;\n\n    // strip the gyp comment line at the beginning\n    config = config.split('\\n').slice(1).join('\\n').replace(/'/g, '\"');\n\n    process.config = JSON.parse(config, function(key, value) {\n      if (value === 'true') return true;\n      if (value === 'false') return false;\n      return value;\n    });\n  };\n\n  startup.processNextTick = function() {\n    var _needTickCallback = process._needTickCallback;\n    var nextTickQueue = [];\n    var needSpinner = true;\n    var inTick = false;\n\n    // this infobox thing is used so that the C++ code in src/node.cc\n    // can have easy accesss to our nextTick state, and avoid unnecessary\n    // calls into process._tickCallback.\n    // order is [length, index, depth]\n    // Never write code like this without very good reason!\n    var infoBox = process._tickInfoBox;\n    var length = 0;\n    var index = 1;\n    var depth = 2;\n\n    process.nextTick = function nextTick(cb) {\n      process._currentTickHandler(cb);\n    };\n\n    // needs to be accessible from cc land\n    process._currentTickHandler = _nextTick;\n    process._nextDomainTick = _nextDomainTick;\n    process._tickCallback = _tickCallback;\n    process._tickDomainCallback = _tickDomainCallback;\n    process._tickFromSpinner = _tickFromSpinner;\n\n    // the maximum number of times it'll process something like\n    // nextTick(function f(){nextTick(f)})\n    // It's unlikely, but not illegal, to hit this limit.  When\n    // that happens, it yields to libuv's tick spinner.\n    // This is a loop counter, not a stack depth, so we aren't using\n    // up lots of memory here.  I/O can sneak in before nextTick if this\n    // limit is hit, which is not ideal, but not terrible.\n    process.maxTickDepth = 1000;\n\n    function tickDone(tickDepth_) {\n      if (infoBox[length] !== 0) {\n        if (infoBox[length] <= infoBox[index]) {\n          nextTickQueue = [];\n          infoBox[length] = 0;\n        } else {\n          nextTickQueue.splice(0, infoBox[index]);\n          infoBox[length] = nextTickQueue.length;\n          if (needSpinner) {\n            _needTickCallback();\n            needSpinner = false;\n          }\n        }\n      }\n      inTick = false;\n      infoBox[index] = 0;\n      infoBox[depth] = tickDepth_;\n    }\n\n    function maxTickWarn() {\n      // XXX Remove all this maxTickDepth stuff in 0.11\n      var msg = '(node) warning: Recursive process.nextTick detected. ' +\n                'This will break in the next version of node. ' +\n                'Please use setImmediate for recursive deferral.';\n      if (process.throwDeprecation)\n        throw new Error(msg);\n      else if (process.traceDeprecation)\n        console.trace(msg);\n      else\n        console.error(msg);\n    }\n\n    function _tickFromSpinner() {\n      needSpinner = true;\n      // coming from spinner, reset!\n      if (infoBox[depth] !== 0)\n        infoBox[depth] = 0;\n      // no callbacks to run\n      if (infoBox[length] === 0)\n        return infoBox[index] = infoBox[depth] = 0;\n      process._tickCallback();\n    }\n\n    // run callbacks that have no domain\n    // using domains will cause this to be overridden\n    function _tickCallback() {\n      var callback, nextTickLength, threw;\n\n      if (inTick) return;\n      if (infoBox[length] === 0) {\n        infoBox[index] = 0;\n        infoBox[depth] = 0;\n        return;\n      }\n      inTick = true;\n\n      while (infoBox[depth]++ < process.maxTickDepth) {\n        nextTickLength = infoBox[length];\n        if (infoBox[index] === nextTickLength)\n          return tickDone(0);\n\n        while (infoBox[index] < nextTickLength) {\n          callback = nextTickQueue[infoBox[index]++].callback;\n          threw = true;\n          try {\n            callback();\n            threw = false;\n          } finally {\n            if (threw) tickDone(infoBox[depth]);\n          }\n        }\n      }\n\n      tickDone(0);\n    }\n\n    function _tickDomainCallback() {\n      var nextTickLength, tock, callback, threw;\n\n      // if you add a nextTick in a domain's error handler, then\n      // it's possible to cycle indefinitely.  Normally, the tickDone\n      // in the finally{} block below will prevent this, however if\n      // that error handler ALSO triggers multiple MakeCallbacks, then\n      // it'll try to keep clearing the queue, since the finally block\n      // fires *before* the error hits the top level and is handled.\n      if (infoBox[depth] >= process.maxTickDepth)\n        return _needTickCallback();\n\n      if (inTick) return;\n      inTick = true;\n\n      // always do this at least once.  otherwise if process.maxTickDepth\n      // is set to some negative value, or if there were repeated errors\n      // preventing depth from being cleared, we'd never process any\n      // of them.\n      while (infoBox[depth]++ < process.maxTickDepth) {\n        nextTickLength = infoBox[length];\n        if (infoBox[index] === nextTickLength)\n          return tickDone(0);\n\n        while (infoBox[index] < nextTickLength) {\n          tock = nextTickQueue[infoBox[index]++];\n          callback = tock.callback;\n          if (tock.domain) {\n            if (tock.domain._disposed) continue;\n            tock.domain.enter();\n          }\n          threw = true;\n          try {\n            callback();\n            threw = false;\n          } finally {\n            // finally blocks fire before the error hits the top level,\n            // so we can't clear the depth at this point.\n            if (threw) tickDone(infoBox[depth]);\n          }\n          if (tock.domain) {\n            tock.domain.exit();\n          }\n        }\n      }\n\n      tickDone(0);\n    }\n\n    function _nextTick(callback) {\n      // on the way out, don't bother. it won't get fired anyway.\n      if (process._exiting)\n        return;\n      if (infoBox[depth] >= process.maxTickDepth)\n        maxTickWarn();\n\n      var obj = { callback: callback, domain: null };\n\n      nextTickQueue.push(obj);\n      infoBox[length]++;\n\n      if (needSpinner) {\n        _needTickCallback();\n        needSpinner = false;\n      }\n    }\n\n    function _nextDomainTick(callback) {\n      // on the way out, don't bother. it won't get fired anyway.\n      if (process._exiting)\n        return;\n      if (infoBox[depth] >= process.maxTickDepth)\n        maxTickWarn();\n\n      var obj = { callback: callback, domain: process.domain };\n\n      nextTickQueue.push(obj);\n      infoBox[length]++;\n\n      if (needSpinner) {\n        _needTickCallback();\n        needSpinner = false;\n      }\n    }\n  };\n\n  function evalScript(name) {\n    var Module = NativeModule.require('module');\n    var path = NativeModule.require('path');\n    var cwd = process.cwd();\n\n    var module = new Module(name);\n    module.filename = path.join(cwd, name);\n    module.paths = Module._nodeModulePaths(cwd);\n    var script = process._eval;\n    if (!Module._contextLoad) {\n      var body = script;\n      script = 'global.__filename = ' + JSON.stringify(name) + ';\\n' +\n               'global.exports = exports;\\n' +\n               'global.module = module;\\n' +\n               'global.__dirname = __dirname;\\n' +\n               'global.require = require;\\n' +\n               'return require(\"vm\").runInThisContext(' +\n               JSON.stringify(body) + ', ' +\n               JSON.stringify(name) + ', true);\\n';\n    }\n    var result = module._compile(script, name + '-wrapper');\n    if (process._print_eval) console.log(result);\n  }\n\n  function errnoException(errorno, syscall) {\n    // TODO make this more compatible with ErrnoException from src/node.cc\n    // Once all of Node is using this function the ErrnoException from\n    // src/node.cc should be removed.\n    var e = new Error(syscall + ' ' + errorno);\n    e.errno = e.code = errorno;\n    e.syscall = syscall;\n    return e;\n  }\n\n  function createWritableStdioStream(fd) {\n    var stream;\n    var tty_wrap = process.binding('tty_wrap');\n\n    // Note stream._type is used for test-module-load-list.js\n\n    switch (tty_wrap.guessHandleType(fd)) {\n      case 'TTY':\n        var tty = NativeModule.require('tty');\n        stream = new tty.WriteStream(fd);\n        stream._type = 'tty';\n\n        // Hack to have stream not keep the event loop alive.\n        // See https://github.com/joyent/node/issues/1726\n        if (stream._handle && stream._handle.unref) {\n          stream._handle.unref();\n        }\n        break;\n\n      case 'FILE':\n        var fs = NativeModule.require('fs');\n        stream = new fs.SyncWriteStream(fd, { autoClose: false });\n        stream._type = 'fs';\n        break;\n\n      case 'PIPE':\n      case 'TCP':\n        var net = NativeModule.require('net');\n        stream = new net.Socket({\n          fd: fd,\n          readable: false,\n          writable: true\n        });\n\n        // FIXME Should probably have an option in net.Socket to create a\n        // stream from an existing fd which is writable only. But for now\n        // we'll just add this hack and set the `readable` member to false.\n        // Test: ./node test/fixtures/echo.js < /etc/passwd\n        stream.readable = false;\n        stream.read = null;\n        stream._type = 'pipe';\n\n        // FIXME Hack to have stream not keep the event loop alive.\n        // See https://github.com/joyent/node/issues/1726\n        if (stream._handle && stream._handle.unref) {\n          stream._handle.unref();\n        }\n        break;\n\n      default:\n        // Probably an error on in uv_guess_handle()\n        throw new Error('Implement me. Unknown stream file type!');\n    }\n\n    // For supporting legacy API we put the FD here.\n    stream.fd = fd;\n\n    stream._isStdio = true;\n\n    return stream;\n  }\n\n  startup.processStdio = function() {\n    var stdin, stdout, stderr;\n\n    process.__defineGetter__('stdout', function() {\n      if (stdout) return stdout;\n      stdout = createWritableStdioStream(1);\n      stdout.destroy = stdout.destroySoon = function(er) {\n        er = er || new Error('process.stdout cannot be closed.');\n        stdout.emit('error', er);\n      };\n      if (stdout.isTTY) {\n        process.on('SIGWINCH', function() {\n          stdout._refreshSize();\n        });\n      }\n      return stdout;\n    });\n\n    process.__defineGetter__('stderr', function() {\n      if (stderr) return stderr;\n      stderr = createWritableStdioStream(2);\n      stderr.destroy = stderr.destroySoon = function(er) {\n        er = er || new Error('process.stderr cannot be closed.');\n        stderr.emit('error', er);\n      };\n      return stderr;\n    });\n\n    process.__defineGetter__('stdin', function() {\n      if (stdin) return stdin;\n\n      var tty_wrap = process.binding('tty_wrap');\n      var fd = 0;\n\n      switch (tty_wrap.guessHandleType(fd)) {\n        case 'TTY':\n          var tty = NativeModule.require('tty');\n          stdin = new tty.ReadStream(fd, {\n            highWaterMark: 0,\n            readable: true,\n            writable: false\n          });\n          break;\n\n        case 'FILE':\n          var fs = NativeModule.require('fs');\n          stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\n          break;\n\n        case 'PIPE':\n        case 'TCP':\n          var net = NativeModule.require('net');\n          stdin = new net.Socket({\n            fd: fd,\n            readable: true,\n            writable: false\n          });\n          break;\n\n        default:\n          // Probably an error on in uv_guess_handle()\n          throw new Error('Implement me. Unknown stdin file type!');\n      }\n\n      // For supporting legacy API we put the FD here.\n      stdin.fd = fd;\n\n      // stdin starts out life in a paused state, but node doesn't\n      // know yet.  Explicitly to readStop() it to put it in the\n      // not-reading state.\n      if (stdin._handle && stdin._handle.readStop) {\n        stdin._handle.reading = false;\n        stdin._readableState.reading = false;\n        stdin._handle.readStop();\n      }\n\n      // if the user calls stdin.pause(), then we need to stop reading\n      // immediately, so that the process can close down.\n      stdin.on('pause', function() {\n        if (!stdin._handle)\n          return;\n        stdin._readableState.reading = false;\n        stdin._handle.reading = false;\n        stdin._handle.readStop();\n      });\n\n      return stdin;\n    });\n\n    process.openStdin = function() {\n      process.stdin.resume();\n      return process.stdin;\n    };\n  };\n\n  startup.processKillAndExit = function() {\n    process.exit = function(code) {\n      if (!process._exiting) {\n        process._exiting = true;\n        process.emit('exit', code || 0);\n      }\n      process.reallyExit(code || 0);\n    };\n\n    process.kill = function(pid, sig) {\n      var r;\n\n      // preserve null signal\n      if (0 === sig) {\n        r = process._kill(pid, 0);\n      } else {\n        sig = sig || 'SIGTERM';\n        if (startup.lazyConstants()[sig] &&\n            sig.slice(0, 3) === 'SIG') {\n          r = process._kill(pid, startup.lazyConstants()[sig]);\n        } else {\n          throw new Error('Unknown signal: ' + sig);\n        }\n      }\n\n      if (r) {\n        throw errnoException(process._errno, 'kill');\n      }\n\n      return true;\n    };\n  };\n\n  startup.processSignalHandlers = function() {\n    // Load events module in order to access prototype elements on process like\n    // process.addListener.\n    var signalWraps = {};\n    var addListener = process.addListener;\n    var removeListener = process.removeListener;\n\n    function isSignal(event) {\n      return event.slice(0, 3) === 'SIG' &&\n             startup.lazyConstants().hasOwnProperty(event);\n    }\n\n    // Wrap addListener for the special signal types\n    process.on = process.addListener = function(type, listener) {\n      if (isSignal(type) &&\n          !signalWraps.hasOwnProperty(type)) {\n        var Signal = process.binding('signal_wrap').Signal;\n        var wrap = new Signal();\n\n        wrap.unref();\n\n        wrap.onsignal = function() { process.emit(type); };\n\n        var signum = startup.lazyConstants()[type];\n        var r = wrap.start(signum);\n        if (r) {\n          wrap.close();\n          throw errnoException(process._errno, 'uv_signal_start');\n        }\n\n        signalWraps[type] = wrap;\n      }\n\n      return addListener.apply(this, arguments);\n    };\n\n    process.removeListener = function(type, listener) {\n      var ret = removeListener.apply(this, arguments);\n      if (isSignal(type)) {\n        assert(signalWraps.hasOwnProperty(type));\n\n        if (this.listeners(type).length === 0) {\n          signalWraps[type].close();\n          delete signalWraps[type];\n        }\n      }\n\n      return ret;\n    };\n  };\n\n\n  startup.processChannel = function() {\n    // If we were spawned with env NODE_CHANNEL_FD then load that up and\n    // start parsing data from that stream.\n    if (process.env.NODE_CHANNEL_FD) {\n      var fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\n      assert(fd >= 0);\n\n      // Make sure it's not accidentally inherited by child processes.\n      delete process.env.NODE_CHANNEL_FD;\n\n      var cp = NativeModule.require('child_process');\n\n      // Load tcp_wrap to avoid situation where we might immediately receive\n      // a message.\n      // FIXME is this really necessary?\n      process.binding('tcp_wrap');\n\n      cp._forkChild(fd);\n      assert(process.send);\n    }\n  }\n\n  startup.resolveArgv0 = function() {\n    var cwd = process.cwd();\n    var isWindows = process.platform === 'win32';\n\n    // Make process.argv[0] into a full path, but only touch argv[0] if it's\n    // not a system $PATH lookup.\n    // TODO: Make this work on Windows as well.  Note that \"node\" might\n    // execute cwd\\node.exe, or some %PATH%\\node.exe on Windows,\n    // and that every directory has its own cwd, so d:node.exe is valid.\n    var argv0 = process.argv[0];\n    if (!isWindows && argv0.indexOf('/') !== -1 && argv0.charAt(0) !== '/') {\n      var path = NativeModule.require('path');\n      process.argv[0] = path.join(cwd, process.argv[0]);\n    }\n  };\n\n  // Below you find a minimal module system, which is used to load the node\n  // core modules found in lib/*.js. All core modules are compiled into the\n  // node binary, so they can be loaded faster.\n\n  var Script = process.binding('evals').NodeScript;\n  var runInThisContext = Script.runInThisContext;\n\n  function NativeModule(id) {\n    this.filename = id + '.js';\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n  }\n\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {};\n\n  NativeModule.require = function(id) {\n    if (id == 'native_module') {\n      return NativeModule;\n    }\n\n    var cached = NativeModule.getCached(id);\n    if (cached) {\n      return cached.exports;\n    }\n\n    if (!NativeModule.exists(id)) {\n      throw new Error('No such native module ' + id);\n    }\n\n    process.moduleLoadList.push('NativeModule ' + id);\n\n    var nativeModule = new NativeModule(id);\n\n    nativeModule.cache();\n    nativeModule.compile();\n\n    return nativeModule.exports;\n  };\n\n  NativeModule.getCached = function(id) {\n    return NativeModule._cache[id];\n  }\n\n  NativeModule.exists = function(id) {\n    return NativeModule._source.hasOwnProperty(id);\n  }\n\n  NativeModule.getSource = function(id) {\n    return NativeModule._source[id];\n  }\n\n  NativeModule.wrap = function(script) {\n    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n  };\n\n  NativeModule.wrapper = [\n    '(function (exports, require, module, __filename, __dirname) { ',\n    '\\n});'\n  ];\n\n  NativeModule.prototype.compile = function() {\n    var source = NativeModule.getSource(this.id);\n    source = NativeModule.wrap(source);\n\n    var fn = runInThisContext(source, this.filename, true);\n    fn(this.exports, NativeModule.require, this, this.filename);\n\n    this.loaded = true;\n  };\n\n  NativeModule.prototype.cache = function() {\n    NativeModule._cache[this.id] = this;\n  };\n\n  startup();\n});\n","undoManager":{"mark":0,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"javascript","scrolltop":5186.000267028809,"scrollleft":0,"selection":{"start":{"row":427,"column":4},"end":{"row":427,"column":4},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":387,"state":"start","mode":"ace/mode/javascript"}}}